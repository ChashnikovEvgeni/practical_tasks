package main

//Написать программу, которая конкурентно рассчитает значение
//квадратов чисел взятых из массива (2,4,6,8,10) и выведет их квадраты в stdout

import (
	"fmt"
	"sync"
	"time"
)

func Task_2_solution() {
	// получение времени за которое было конкурентно рассчитано значение квадратов
	C_time := Concurrent_solution()
	//получение времени выполнения операции без использования конкурентных вычислений
	WC_time := WithoutConcurrent_solution()
	// Вывод результата сравения двух полученных показателей времени
	fmt.Printf("Разница времени работы без использованием конкурентых вычислений и с их использованием: %g", WC_time-C_time) //результат как минимум скромный

}

// Выполнение поставленной задачи с использованием конкурентных вычислений
func Concurrent_solution() float64 {
	var wg sync.WaitGroup
	numbers := []int{2, 4, 6, 8, 10}
	//Запись текущего времени
	start := time.Now()

	for _, number := range numbers {
		//Добавление одной задачи в WaitGroup
		wg.Add(1)
		// Создание go рутины
		go func(n int) {
			// Сообщение для WaitGroup о том, что решение задачи завершено, сработает лишь по выполнению всех операций внутри данной функции
			defer wg.Done()
			// Вывод значения числа, для которого вычисляется квадрат, и самого квадрата данного значения
			// Так как, fmt.Printf использует Fprintf(os.Stdout, format, a...), которая в свою очередь использует
			// os.stdout, вывод в stdout производиться с помощью данной команды.
			fmt.Printf("Квадрат числа %d равен: %d", n, n*n)
			// Итоговый вывод будет каждый раз разным, ввиду того, что некоторые операции заканчивают вычисления быстрее
			// Но получаемые числа в данном случае будут одними и теми же, но в разном порядке
			// Один из возможных output:
			//Квадрат числа 4 равен: 16
			//Квадрат числа 2 равен: 4
			//Квадрат числа 10 равен: 100
			//Квадрат числа 8 равен: 64
			//Квадрат числа 6 равен: 36
			//Время выполнения c использованием конкурентых вычислений: 0.0005093
		}(number) // предача значения в аномнимную функцию
	}
	//Блокировка основной go рутины до момента выполнения всего списка задач
	wg.Wait()
	// метод Sub возращает длительность, считаемую с момента указанном в переменной start
	finalTime := time.Now().Sub(start).Seconds()
	//Вывод итогового времени выполнения всех операций
	fmt.Printf("Время выполнения c использованием конкурентых вычислений: %g", finalTime)
	return finalTime
}

// Выполнение поставленной задачи без использования конкурентных вычислений
func WithoutConcurrent_solution() float64 {
	numbers := []int{2, 4, 6, 8, 10}
	//Запись текущего времени
	start := time.Now()

	for _, number := range numbers {
		// Вывод значения числа, для которого вычисляется квадрат, и самого квадрата данного значения
		fmt.Printf("Квадрат числа %d равен: %d", number, number*number)

	}
	// метод Sub возращает длительность, считаемую с момента указанном в переменной start
	finalTime := time.Now().Sub(start).Seconds()
	//Вывод итогового времени выполнения всех операций
	fmt.Printf("Время выполнения без использования конкурентых вычислений: %g", finalTime)
	return finalTime
}
