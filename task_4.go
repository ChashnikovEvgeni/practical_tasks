package main

//Реализовать постоянную запись данных в канал (главный поток).
//	Реализовать набор из N воркеров, которые читают произвольные данные из канала и выводят в stdout.
//	Необходима возможность выбора количества воркеров при старте.
//	Программа должна завершаться по нажатию Ctrl+C.
//	Выбрать и обосновать способ завершения работы всех воркеров.

import (
	"fmt"
	"math/rand"
	"os"
	"os/signal"
	"syscall"
)

func Task_4_solution() {
	// переменная для хранения числа воркеров
	var amount int
	//канал для передачи системных сигналов
	sigChan := make(chan os.Signal, 1)
	// ретрансляция определённых системных сигналов в канал
	//сигнал SIGINT отправляется когда пользователь нажимает символ прерывания
	signal.Notify(sigChan, syscall.SIGINT)

	// канал для передачи чисел, генерируемых в бесконечном цикле
	dataChan := make(chan int)

	// запрос у пользователя колиснмтва воркеров
	fmt.Println("Введите количество воркеров")
	fmt.Scanf("%d\n", &amount)
	// запуск функции создания воркеров
	makeWorkers(&amount, dataChan)

	//метка, необходимая для остановки беконечного цикла из select
	// обычный вызов break останавливается только вложенную часть (в данном случае select)
writeLoop:
	//бесконечный цикл для передачи в канал случайных значений
	for {
		// оператор для ожидание отправки или получения данных из каналов
		select {
		// блок срабатывающий в случае появления данных в канал sigChan
		// в него приходит сообщение о заверщении программы
		case sig := <-sigChan:
			close(dataChan)
			fmt.Println("Остановка по сигналу", sig)
			break writeLoop
		// данный блок запускается если не сработали другие блоки
		default:
			dataChan <- rand.Int()

		}
	}

}

// функция создания воркеров
func makeWorkers(n *int, ch chan int) {
	for i := 1; i < *n; i++ {
		go func(i int) {
			// получение данных из канал до его закрытия
			for number := range ch {
				fmt.Printf("Воркер номер:%d, получено число: %d \n", i, number)
			}
		}(i)
	}

}
